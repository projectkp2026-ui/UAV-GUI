<!DOCTYPE html>
<html lang="en">
<head>
    <title>UAV 3D Visualization (Interactive Users)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; }
        canvas { display: block; }
        #tooltip {
            position: absolute;
            display: none;
            padding: 8px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            font-family: sans-serif;
            font-size: 12px;
            z-index: 100;
        }
        #ui-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            z-index: 100;
        }
        #ui-controls button {
            width: 30px;
            height: 30px;
            font-size: 20px;
            font-weight: bold;
            margin: 0 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            padding: 0; 
            line-height: 30px; 
        }
        
        #user-count {
            color: white;
            font-family: sans-serif;
            font-size: 16px;
            margin: 0 10px;
            min-width: 80px;
            text-align: center;
        }

        #drone-controls {
            position: absolute;
            top: 15px;
            right: 15px; 
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column; 
            align-items: center;
            z-index: 100;
        }
        #drone-controls button {
            width: 30px;
            height: 30px;
            font-size: 20px;
            font-weight: bold;
            margin: 5px 0; 
            cursor: pointer;
            border: none;
            border-radius: 5px;
            padding: 0; 
            line-height: 30px; 
        }
        
        #drone-height-label {
            color: white;
            font-family: sans-serif;
            font-size: 14px;
            margin: 5px 0;
            min-width: 80px;
            text-align: center;
        }
        
        /* --- IMPROVED CSS FOR REAL-TIME STATS PANEL --- */
        #real-time-stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            
            background: rgba(0, 0, 0, 0.3);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            
            padding: 12px;
            padding-bottom: 10px;
            border-radius: 12px;
            z-index: 100;
            
            display: flex;
            align-items: center;
            
            white-space: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        #real-time-stats::-webkit-scrollbar {
            height: 6px;
        }
        #real-time-stats::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        #real-time-stats::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        #real-time-stats::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .user-stat-card {
            flex-shrink: 0;
            min-width: 160px;
            
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px 14px;
            margin-right: 12px;
            
            font-family: sans-serif;
            color: white;
            
            transition: all 0.2s ease-out;
        }

        .user-stat-card:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.12);
        }

        .user-stat-card .label {
            display: block;
            font-weight: 600;
            color: #c0c0c0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .user-stat-card .value-container {
            display: flex;
            align-items: baseline;
            justify-content: flex-end;
            margin-top: 6px;
        }
        
        .user-stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #50fa7b;
        }

        .user-stat-card .unit {
            font-size: 11px;
            font-weight: 500;
            color: #c0c0c0;
            margin-left: 5px;
        }
        
        .user-stat-card .danger {
            color: #ff5555;
            animation: pulse-danger 1.5s infinite alternate;
        }

        @keyframes pulse-danger {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

    </style>
</head>
<body>
    <div id="tooltip"></div>
    
    <div id="ui-controls">
        <button id="remove-user" title="Remove User">-</button>
        <div id="user-count">6 Users</div>
        <button id="add-user" title="Add User">+</button>
    </div>

    <div id="drone-controls">
        <div id="drone-height-label">Height: 37m</div>
        <button id="increase-height" title="Increase Height">+</button>
        <button id="decrease-height" title="Decrease Height">-</button>
        <button id="toggle-roam" title="Toggle Random Roaming">ðŸ”„</button>
    </div>

    <div id="real-time-stats">
        </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, controls;
        let uav, gbs;
        let users = [];
        let signalLines = [];
        let gbsToUavLine; 
        let interactiveObjects = [];
        let loadedBuildingModel; 
        
        let droneBaseHeight = 37;
        let droneHeightLabel;
        let droneHeightControls; 
        
        let isRoaming = false;
        let uavRoamTarget = new THREE.Vector3();
        let toggleRoamButton;

        let userStatsContainer;
        const UAV_POWER = 10000;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const hoverPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -15);
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersection = new THREE.Vector3();
        let isDragging = false;
        let draggedObject = null; 

        const hoverRay = new THREE.Raycaster();
        const tooltip = document.getElementById('tooltip');
        let lastHovered = null;

        const userCountLabel = document.getElementById('user-count');

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 250);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 70);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2.1;

            // Lighting
            const ambLight = new THREE.AmbientLight(0x606060);
            scene.add(ambLight);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Ground & Water
            const groundGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x559020 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const waterGeo = new THREE.PlaneGeometry(200, 80);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x0066ff, metalness: 0.8, roughness: 0.1, transparent: true, opacity: 0.7 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.set(0, -0.1, -60);
            scene.add(water);

            // Inoperative GBS (Base Station)
            gbs = createGbsBaseStation();
            gbs.position.set(-30, 0, -20);
            gbs.userData.name = "Base Station";
            scene.add(gbs);
            interactiveObjects.push(gbs);

            // Single UAV (UmBS - Drone)
            uav = createDrone(); 
            uav.position.set(0, 15, 0); 
            uav.userData.name = "UAV (Drone)";
            scene.add(uav);
            interactiveObjects.push(uav);
            
            // Get stats panel *before* adding users
            userStatsContainer = document.getElementById('real-time-stats');

            // Users (UEs - Persons)
            const uePositions = [
                [15, 0, 15], [-10, 0, 10], [20, 0, -5], [-5, 0, -15], [0, 0, 20], [30, 0, 0]
            ];
            uePositions.forEach((pos, index) => {
                addUser(new THREE.Vector3(pos[0], pos[1], pos[2]));
            });
            updateUserCount();

            // Create Tower-to-UAV Ray (Red)
            const gbsTopPos = gbs.position.clone().add(new THREE.Vector3(0, 31, 0)); 
            const gbsRayMat = new THREE.LineBasicMaterial({
                color: 0xff0000,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            const gbsRayPoints = [gbsTopPos, uav.position.clone()];
            const gbsRayGeo = new THREE.BufferGeometry().setFromPoints(gbsRayPoints);
            gbsToUavLine = new THREE.Line(gbsRayGeo, gbsRayMat);
            scene.add(gbsToUavLine);

            // Load GLB Buildings
            const buildingPositions = [
                [40, 0, 40], [-40, 0, 30], [20, 0, -30], [-10, 0, 40], [50, 0, -10], [-50, 0, -40], [45, 0, 10]
            ];
            const loader = new GLTFLoader();
            loader.load(
                'building.glb', 
                function (gltf) {
                    loadedBuildingModel = gltf.scene;
                    
                    loadedBuildingModel.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });

                    buildingPositions.forEach((pos, index) => {
                        const buildingClone = loadedBuildingModel.clone();
                        buildingClone.position.set(pos[0], pos[1], pos[2]);
                        buildingClone.scale.set(3, 6, 4); 
                        buildingClone.userData.name = `Building ${index + 1}`;
                        scene.add(buildingClone);
                        interactiveObjects.push(buildingClone);
                    });
                },
                undefined, 
                function (error) {
                    console.error('Error loading building.glb:', error);
                }
            );

            // Trees
            for (let i = 0; i < 20; i++) {
                const tree = createTree();
                let x = Math.random() * 160 - 80;
                let z = Math.random() * 160 - 80;
                if (z > -20 && z < 20) z = 20 + Math.random() * 60; 
                tree.position.set(x, 0, z);
                tree.userData.name = "Tree";
                scene.add(tree);
                interactiveObjects.push(tree);
            }
            
            droneHeightControls = [
                document.getElementById('increase-height'),
                document.getElementById('decrease-height')
            ];

            toggleRoamButton = document.getElementById('toggle-roam');
            toggleRoamButton.addEventListener('click', toggleRoaming);
            uavRoamTarget.copy(uav.position); 

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            document.getElementById('add-user').addEventListener('click', () => addUser());
            document.getElementById('remove-user').addEventListener('click', removeUser);

            // Drone Height Listeners
            droneHeightLabel = document.getElementById('drone-height-label');
            droneHeightControls[0].addEventListener('click', () => {
                droneBaseHeight += 2;
                updateDroneHeightLabel();
            });
            droneHeightControls[1].addEventListener('click', () => {
                droneBaseHeight = Math.max(5, droneBaseHeight - 2);
                updateDroneHeightLabel();
            });
        }
        
        // --- HELPER FUNCTIONS ---
        
        function updateDroneHeightLabel() {
            if (droneHeightLabel) {
                droneHeightLabel.textContent = `Height: ${droneBaseHeight}m`;
            }
        }

        function toggleRoaming() {
            isRoaming = !isRoaming;
            
            if (isRoaming) {
                setNewRoamTarget();
                toggleRoamButton.style.background = '#00ff00';
            } else {
                uavRoamTarget.copy(uav.position); 
                toggleRoamButton.style.background = '';
            }
        }

        function setNewRoamTarget() {
            const rX = Math.random() * 80 - 40;
            const rZ = Math.random() * 80 - 40;
            uavRoamTarget.set(rX, droneBaseHeight, rZ);
        }
        
        // --- Create Model Functions ---

        function createDrone() {
            const droneGroup = new THREE.Group();
            
            // --- Materials (White & Black Scheme) ---
            const whiteBodyMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, // White body
                metalness: 0.2, 
                roughness: 0.4 
            });
            const darkAccentMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, // Dark grey/black for arms, gear, motors
                metalness: 0.1, 
                roughness: 0.6 
            });
            const darkTopPlateMat = new THREE.MeshStandardMaterial({
                color: 0x444444, // Slightly lighter black for the top plate
                metalness: 0.1,
                roughness: 0.5
            });
            const propMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, // Very dark, slightly transparent props
                roughness: 0.8, 
                transparent: true, 
                opacity: 0.7 
            });
            const cameraMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                metalness: 0.8, 
                roughness: 0.2 
            });
            const gimbalMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.4,
                roughness: 0.5
            });
            // Emissive lights (colors remain for function)
            const greenLightMat = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 2
            });
             const redLightMat = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 2
            });
             const signalLightMat = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                emissive: 0x00aaff,
                emissiveIntensity: 1
            });

            // --- Main Body (White, slightly refined shape) ---
            const bodyGeo = new THREE.BoxGeometry(2.0, 0.6, 3.2); // Slightly smaller, sleeker
            const body = new THREE.Mesh(bodyGeo, whiteBodyMat);
            body.castShadow = true;
            droneGroup.add(body);

            // --- Top plate for contrast (Dark grey) ---
            const topPlateGeo = new THREE.BoxGeometry(1.6, 0.1, 2.6);
            const topPlate = new THREE.Mesh(topPlateGeo, darkTopPlateMat);
            topPlate.position.y = 0.35; 
            droneGroup.add(topPlate);

            // --- Arm Geometry (Thinner, more technical) ---
            const armGeo = new THREE.BoxGeometry(2.8, 0.2, 0.1); // Longer and thinner
            
            // --- Propeller Geometry ---
            const propGeo = new THREE.BoxGeometry(1.8, 0.02, 0.2);
            
            // --- Motor Geometry (Stacked Cylinders) ---
            const motorBaseGeo = new THREE.CylinderGeometry(0.2, 0.18, 0.2, 8);
            const motorTopGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
            const lightGeo = new THREE.SphereGeometry(0.05, 6, 6);
            
            // Function to create one full arm assembly (Arm + Motor + Prop)
            // It now takes `armAngle` for diagonal placement
            function createArmAssembly(armAngle, lightMat) {
                const armGroup = new THREE.Group(); // Group for arm, motor, prop, light
                
                const arm = new THREE.Mesh(armGeo, darkAccentMat);
                arm.position.x = 1.4; // Position along the arm's local X
                arm.castShadow = true;
                armGroup.add(arm);

                // Motor Group (Stacked Cylinders)
                const motorGroup = new THREE.Group();
                const motorBase = new THREE.Mesh(motorBaseGeo, darkAccentMat);
                const motorTop = new THREE.Mesh(motorTopGeo, darkAccentMat);
                motorTop.position.y = 0.3; 
                motorGroup.add(motorBase, motorTop);
                
                motorGroup.position.x = 1.4; // End of the arm relative to armGroup's center
                motorGroup.position.y = 0.2; 
                arm.add(motorGroup); 

                // Propeller
                const prop = new THREE.Mesh(propGeo, propMat);
                prop.position.y = 0.25; 
                prop.userData.isPropeller = true; 
                motorTop.add(prop);
                
                // Add light if material is provided
                if (lightMat) {
                    const light = new THREE.Mesh(lightGeo, lightMat);
                    light.position.x = 1.4; // End of arm
                    light.position.z = 0.1; // Front of arm
                    arm.add(light);
                }

                // Rotate the entire arm group to its diagonal position
                armGroup.rotation.y = armAngle;
                droneGroup.add(armGroup); // Add the whole arm assembly to the droneGroup
                
                return armGroup; // Return the group to potentially store for later reference
            }

            // Create 4 arms at perfect diagonal ends (Symmetrical)
            const armOffset = 1.0; // Distance from center for the pivot of each arm
            createArmAssembly(Math.PI / 4, greenLightMat);   // Front-right (Green)
            createArmAssembly(Math.PI * 3 / 4, redLightMat); // Back-left (Red)
            createArmAssembly(Math.PI * 5 / 4, redLightMat); // Back-right (Red)
            createArmAssembly(Math.PI * 7 / 4, redLightMat); // Front-left (Red)
            
            // --- Camera / Gimbal (Black) ---
            const gimbalGroup = new THREE.Group();
            const gimbalGeo = new THREE.SphereGeometry(0.25, 8, 8); // Slightly smaller gimbal
            const gimbal = new THREE.Mesh(gimbalGeo, gimbalMat);
            gimbal.position.y = -0.3;
            gimbalGroup.add(gimbal);
            
            const lensGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 8);
            const lens = new THREE.Mesh(lensGeo, cameraMat);
            lens.rotation.x = Math.PI / 2;
            lens.position.z = 0.25;
            gimbal.add(lens);
            
            // Position gimbal at the front
            gimbalGroup.position.z = 1.4; // Slightly further forward for visual balance
            gimbalGroup.position.y = -0.5; // Lower relative to body
            droneGroup.add(gimbalGroup);

            // --- Landing Gear (Skids) - More "technical" Boxy look, now black ---
            const skidHorizGeo = new THREE.BoxGeometry(0.1, 0.1, 2.5); // Horizontal part of skid
            const skidVertGeo = new THREE.BoxGeometry(0.1, 0.8, 0.1); // Vertical posts
            
            function createSkidSet(xPos) {
                const skidGroup = new THREE.Group();
                
                const horizSkid = new THREE.Mesh(skidHorizGeo, darkAccentMat);
                horizSkid.position.set(xPos, -1.0, 0); // Lower
                skidGroup.add(horizSkid);
                
                const vertPost1 = new THREE.Mesh(skidVertGeo, darkAccentMat);
                vertPost1.position.set(xPos, -0.6, 1.0); // Connects to body
                skidGroup.add(vertPost1);
                
                const vertPost2 = new THREE.Mesh(skidVertGeo, darkAccentMat);
                vertPost2.position.set(xPos, -0.6, -1.0); // Connects to body
                skidGroup.add(vertPost2);

                return skidGroup;
            }
            
            droneGroup.add(createSkidSet(0.8)); // Symmetrical placement
            droneGroup.add(createSkidSet(-0.8));

            // --- Emitter (the blue light) ---
            const emitter = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), signalLightMat); // Smaller emitter
            emitter.position.y = 0; 
            emitter.position.z = 0.15; // Slightly in front of lens
            lens.add(emitter); // Add to lens

            droneGroup.userData.name = "UAV (Drone)";
            return droneGroup;
        }
        
        function createGbsBaseStation() {
            const towerGroup = new THREE.Group();
            const antennaTopY = 31; 

            const blackMat = new THREE.MeshBasicMaterial({ 
                color: 0x111111, 
                wireframe: true 
            });
            
            const whiteMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                wireframe: true 
            });

            const mainTowerGeo = new THREE.ConeGeometry(4, 30, 4, 10); 
            const mainTower = new THREE.Mesh(mainTowerGeo, blackMat);
            mainTower.position.y = 15; 
            towerGroup.add(mainTower);

            const centerSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), whiteMat);
            centerSphere.position.y = antennaTopY;
            towerGroup.add(centerSphere);

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(1, 0.1, 4, 12), whiteMat);
            ring1.position.y = antennaTopY;
            ring1.rotation.x = Math.PI / 2;
            towerGroup.add(ring1);
            
            const ring2 = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.1, 4, 12), whiteMat);
            ring2.position.y = antennaTopY;
            ring2.rotation.x = Math.PI / 2;
            towerGroup.add(ring2);
            
            const ring3 = new THREE.Mesh(new THREE.TorusGeometry(2, 0.1, 4, 12), whiteMat);
            ring3.position.y = antennaTopY;
            ring3.rotation.x = Math.PI / 2;
            towerGroup.add(ring3);
            
            return towerGroup;
        }

        function createPerson() {
            const personGroup = new THREE.Group();
            const headMat = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 4.3; 
            head.castShadow = true;
            personGroup.add(head);

            const bodyMat = new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5) });
            const bodyGeo = new THREE.CylinderGeometry(0.4, 0.3, 2.0, 8); 
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 3.0; 
            body.castShadow = true;
            personGroup.add(body);

            const legsMat = new THREE.MeshLambertMaterial({ color: 0x444488 });
            const legGeo = new THREE.CylinderGeometry(0.2, 0.15, 2.0, 6); 
            const leg1 = new THREE.Mesh(legGeo, legsMat);
            leg1.position.set(0.2, 1.0, 0); 
            leg1.castShadow = true;
            personGroup.add(leg1);

            const leg2 = new THREE.Mesh(legGeo, legsMat);
            leg2.position.set(-0.2, 1.0, 0); 
            leg2.castShadow = true;
            personGroup.add(leg2);

            const armMat = new THREE.MeshLambertMaterial({ color: 0xffdbac }); 
            const armGeo = new THREE.CylinderGeometry(0.1, 0.08, 1.4, 6);
            
            const arm1 = new THREE.Mesh(armGeo, armMat);
            arm1.castShadow = true;
            arm1.position.set(0.5, 3.2, 0); 
            arm1.rotation.z = Math.PI / 4; 
            personGroup.add(arm1);

            const arm2 = new THREE.Mesh(armGeo, armMat);
            arm2.castShadow = true;
            arm2.position.set(-0.5, 3.2, 0); 
            arm2.rotation.z = -Math.PI / 8; 
            personGroup.add(arm2);

            const phoneMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                metalness: 0.8, 
                roughness: 0.4 
            });
            const phoneGeo = new THREE.BoxGeometry(0.3, 0.6, 0.05);
            const phone = new THREE.Mesh(phoneGeo, phoneMat);
            phone.castShadow = true;
            
            phone.position.y = -0.5; 
            phone.position.z = 0.1;  
            phone.rotation.z = -Math.PI / 3; 
            
            arm1.add(phone); 

            return personGroup;
        }

        function createTree() {
            const treeGroup = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 4, 6);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            const foliageGeo = new THREE.ConeGeometry(2.5, 6, 8);
            const foliageMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 4 + 3;
            foliage.castShadow = true;
            treeGroup.add(foliage);
            return treeGroup;
        }

        // --- Add/Remove User Functions ---
        
        function updateUserCount() {
            userCountLabel.textContent = `${users.length} User${users.length !== 1 ? 's' : ''}`;
        }

        function addUser(position) {
            const person = createPerson();
            
            if (!position) {
                position = new THREE.Vector3(
                    Math.random() * 80 - 40,
                    0,
                    Math.random() * 80 - 40
                );
            }
            person.position.copy(position);
            person.userData.name = `User ${users.length + 1}`;
            
            users.push(person);
            scene.add(person);
            interactiveObjects.push(person);

            createSignalLine(person);
            
            if (userStatsContainer) {
                const userStatDiv = document.createElement('div');
                userStatDiv.className = 'user-stat-card';
                userStatDiv.id = `user-stat-${person.uuid}`; 
                
                userStatDiv.innerHTML = `<span class="label">${person.userData.name}</span><div class="value-container"><span class="value" id="rate-${person.uuid}">--</span> <span class="unit">bits/s/Hz</span></div>`;
                
                userStatsContainer.appendChild(userStatDiv);
            }

            updateUserCount();
        }

        function removeUser() {
            if (users.length === 0) return;

            const person = users.pop();
            const line = signalLines.pop();

            scene.remove(person);
            scene.remove(line);

            const index = interactiveObjects.indexOf(person);
            if (index > -1) {
                interactiveObjects.splice(index, 1);
            }

            if (userStatsContainer) {
                const userStatDiv = document.getElementById(`user-stat-${person.uuid}`);
                if (userStatDiv) {
                    userStatsContainer.removeChild(userStatDiv);
                }
            }

            line.geometry.dispose();
            line.material.dispose();
            person.traverse(obj => {
                if (obj.isMesh) {
                    obj.geometry.dispose();
                    obj.material.dispose();
                }
            });

            updateUserCount();
        }
        
        // --- Interactivity Logic ---

        function createSignalLine(user) {
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x00aaff, 
                linewidth: 2, 
                transparent: true, 
                opacity: 0.7 
            });
            
            const userHeadPos = user.position.clone().add(new THREE.Vector3(0, 4.3, 0)); 
            const points = [uav.position.clone(), userHeadPos]; 
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, lineMat.clone());
            
            signalLines.push(line);
            scene.add(line);
        }

        function createRedXTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(200, 0, 0, 0.7)';
            context.fillRect(0, 0, size, size);
            context.strokeStyle = 'white';
            context.lineWidth = 15;
            context.beginPath();
            context.moveTo(15, 15);
            context.lineTo(size - 15, size - 15);
            context.moveTo(size - 15, 15);
            context.lineTo(15, size - 15);
            context.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Dragging Logic ---
        function onMouseDown(event) {
            if (!uav) return; 

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            
            if (intersects.length > 0) {
                let hoveredObj = intersects[0].object;
                while (hoveredObj.parent && !hoveredObj.userData.name) {
                    hoveredObj = hoveredObj.parent;
                }
                
                if (hoveredObj === uav || users.includes(hoveredObj)) {
                    isDragging = true;
                    draggedObject = hoveredObj;
                    controls.enabled = false;
                }
            }
        }

        function onMouseMove(event) {
            const mX = event.clientX;
            const mY = event.clientY;
            mouse.x = (mX / window.innerWidth) * 2 - 1;
            mouse.y = -(mY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (isDragging && draggedObject) { 
                if (draggedObject === uav) {
                    if (raycaster.ray.intersectPlane(hoverPlane, intersection)) {
                        uav.position.copy(intersection);
                    }
                } else if (users.includes(draggedObject)) {
                    if (raycaster.ray.intersectPlane(groundPlane, intersection)) {
                        draggedObject.position.copy(intersection);
                    }
                }
            } 
            else { 
                hoverRay.setFromCamera(mouse, camera);
                const intersects = hoverRay.intersectObjects(interactiveObjects, true); 
                
                if (intersects.length > 0) {
                    let hoveredObj = intersects[0].object;
                    while (hoveredObj.parent && !hoveredObj.userData.name) {
                        hoveredObj = hoveredObj.parent;
                    }
                    if (lastHovered !== hoveredObj && hoveredObj.userData.name) {
                        lastHovered = hoveredObj;
                        tooltip.style.display = 'block';
                        tooltip.textContent = hoveredObj.userData.name;
                    }
                    tooltip.style.left = (mX + 10) + 'px';
                    tooltip.style.top = (mY + 10) + 'px';
                } else {
                    if (lastHovered) {
                        tooltip.style.display = 'none';
                        lastHovered = null;
                    }
                }
            }
        }

        function onMouseUp() {
            isDragging = false;
            draggedObject = null; 
            controls.enabled = true;
        }

        // --- NEW FUNCTION INSERTED HERE ---
        function calculateDataRate(uavPos, userPos) {
        Â  Â  // ------------------------------
        Â  Â  // 1) Distance between UAV & User
        Â  Â  // ------------------------------
        Â  Â  const d = uavPos.distanceTo(userPos);

        Â  Â  // ------------------------------
        Â  Â  // 2) Channel Gain |h|^2
        Â  Â  // Free-space or urban: d^-alpha
        Â  Â  // ------------------------------
        Â  Â  const alpha = 2.2;Â  // MMwave / urban LoS exponent (realistic)
        Â  Â  const h_sq = 1 / Math.pow(d, alpha);

        Â  Â  // ------------------------------
        Â  Â  // 3) SINR = P * |h|^2 / noise
        Â  Â  // ------------------------------
        Â  Â  const P = UAV_POWER;Â  Â  Â  Â  Â // you already have this
        Â  Â  const noise = 1e-9;Â  Â  Â  Â  Â  // VERY IMPORTANT! realistic noise power

        Â  Â  const SINR = (P * h_sq) / noise;

        Â  Â  // ------------------------------
        Â  Â  // 4) Rate (Shannon Capacity)
        Â  Â  // returns: bits/s/Hz = spectral efficiency
        Â  Â  // ------------------------------
        Â  Â  const rate = Math.log2(1 + SINR);

        Â  Â  return rate;
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();
            
            if (uav) {
                
                uav.traverse((child) => {
                    if (child.isMesh && child.userData.isPropeller === true) {
                        child.rotation.y += 0.5;
                    }
                });

                if (!isDragging || draggedObject !== uav) { 
                    
                    if (isRoaming) {
                        uavRoamTarget.y = droneBaseHeight;
                        uav.position.lerp(uavRoamTarget, 0.01);
                        
                        if (uav.position.distanceTo(uavRoamTarget) < 2.0) {
                            setNewRoamTarget();
                        }

                    } else {
                        uav.position.y = droneBaseHeight + Math.sin(time * 0.0015) * 0.7; 
                        uavRoamTarget.set(uav.position.x, droneBaseHeight, uav.position.z);
                    }
                    
                    hoverPlane.set(new THREE.Vector3(0, 1, 0), -uav.position.y);
                }

                const uavPos = uav.position;

                signalLines.forEach((line, index) => {
                    const user = users[index];
                    if (!user) return; 

                    const userHeadPos = user.position.clone().add(new THREE.Vector3(0, 4.3, 0));
                    const positions = line.geometry.attributes.position.array;
                    
                    positions[0] = uavPos.x;
                    positions[1] = uavPos.y; // <-- THIS IS NOW CORRECT
                    positions[2] = uavPos.z;
                    
                    positions[3] = userHeadPos.x;
                    positions[4] = userHeadPos.y;
                    positions[5] = userHeadPos.z;

                    line.geometry.attributes.position.needsUpdate = true;
                    line.material.opacity = 0.6 + Math.sin(time * 0.003 + index) * 0.3;
                });

                if (gbsToUavLine) {
                    const positions = gbsToUavLine.geometry.attributes.position.array;
                    positions[3] = uavPos.x; 
                    positions[4] = uavPos.y; 
                    positions[5] = uavPos.z; 
                    gbsToUavLine.geometry.attributes.position.needsUpdate = true;
                    gbsToUavLine.material.opacity = 0.5 + Math.cos(time * 0.002) * 0.3;
                }

                if (uav && users.length > 0) {
                    users.forEach((user) => {
                        const userStatDiv = document.getElementById(`user-stat-${user.uuid}`);
                        if (userStatDiv) {
                            const rate = calculateDataRate(uav.position, user.position);
                            
                            const valueSpan = userStatDiv.querySelector('.value'); 
                            valueSpan.textContent = rate.toFixed(2);
                            
                            if (rate < 5.0) {
                                valueSpan.className = 'value danger';
                            } else {
                                valueSpan.className = 'value';
                            }
                        }
                    });
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>